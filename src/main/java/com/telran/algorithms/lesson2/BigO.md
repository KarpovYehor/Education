Big O notation :
O(1) - постоянная (константная)   !!!! (код который не зависит от размера данных)
O(n) - линейная (одинарные циклы с простым кодом внутри, например линейный поиск)
O(n^2) - квадратическая (цикл в цикле(в зависимости от входных данных), обход двумерного массива,
сортировка пузырьком)
O(n^3) - кубическая
O(log n) - логарифмическая (постоянное деление входных данных пополам в цикле,
бинарный поиск(двоичный поиск), поиск по дереву бинарному)
O(n log n) - linear log (сортировка слиянием, сортировка быстрая)


Time complexity -  временная сложность
Space complexity - пространственная сложность

array - n elements
find element in array
[6,7,2,6,8,4,5,85,12,14]
find 12 : return true if is exists

k = 12;
[6,7,2,6,8,4,5,85,12,14]
[12,7,2,6,8,4,5,85,5,14]
[6,7,2,6,8,4,5,85,14,12]
[6,7,2,6,8,4,12,85,8,14]

n - где н это количество элементов в массиве

for(i = 0, i < array.length, i++){
    if(k == array[i]){
        return true;
    }
}
return false;

Time complexity O(n) linear

[6,7,2,6,8,4,5,85,12,14]

a = array[5];     O(1) 
k = 12;           O(1)
k = k + 15;       O(1)
if(k == 12)       O(1)
i++               O(1)
i < array.length  O(1)

Time complexity = O(1) + O(1) = O(1+1) = O(2) = O(1)
Время выполнения - порядок роста функции, который показывает как растет 
функция с изменением количества входных данных
{
k = 10;      O(1)
k = k + 25;  O(1)
}

Comp 1: 0.1, 0.1, 0.1 = 0.1 = O(1)
Comp 2: 0.002, 0.002, 0.002 = 0.002 = O(1)

Time complexity - ? O(1) + O(1) + O(1) + O(1) = O(4) = O(1)
{
    i = 100;           O(1)
    i = i - 100 / 2;   O(1)
    if(i == 50) {      O(1)
        i = 30;        O(1)
    }
}

array
Time complexity - ?

1-1c
10 - 10c
100 - 100c
...
Когда есть зависимость времени выполнения кода от количества входных данных
это называется "порядок роста" - который мы оцениваем как Big O

getSum{
    sum = 0;    // 1
    for(i = 0; i < array.length; i++){   i = 0 //1,  i < array.length //1 * n,   i++ //1 * n
        sum = sum + array[i]; // 1 * n
    }
    return sum;  // 1
}
sum = 0               : 1
i = 0                 : 1
i < array.length      : 1 * n
i++                   : 1 * n
sum = sum + array[i]  : 1 * n
return sum            : 1

Отдельные константы можно отбросить, потому что они никак не влияют на порядок роста
Когда сложность состоит из нескольких слагаемых, всегда остается самый худший случай
Принято все числа у параметров тоже отбрасывать
1 + 1 + n + n + n + 1 = 3 + 3n = 3n = n 


Comp 1: 100 = n
Comp 2: 1000 = 20n


-------------------------------------

{
    sum = 0;  //1
    for(i = 0; i < 10; i++){  i = 0 //1, i < 10 //1 * 10, i++ //1 * 10 
        sum = sum + i; // 1 * 10
    }
}
1 + 1 + 10 + 10 + 10 = 32 = O(1);
Time complexity = O(1);
Space complexity = O(1);